import{b as R}from"./browser-polyfill-CXcayLWt.js";import{H as de,I as re}from"./vendor-KxyM20Hl.js";let se=()=>({events:{},emit(e,...r){(this.events[e]||[]).forEach(s=>s(...r))},on(e,r){return(this.events[e]=this.events[e]||[]).push(r),()=>this.events[e]=(this.events[e]||[]).filter(s=>s!==r)}});var ne={exports:{}};(function(e,r){(function(s,i){i(e)})(typeof globalThis<"u"?globalThis:typeof self<"u"?self:de,function(s){if(typeof globalThis!="object"||typeof chrome!="object"||!chrome||!chrome.runtime||!chrome.runtime.id)throw new Error("This script should only be loaded in a browser extension.");if(typeof globalThis.browser>"u"||Object.getPrototypeOf(globalThis.browser)!==Object.prototype){const i="The message port closed before a response was received.",u="Returning a Promise is the preferred way to send a reply from an onMessage/onMessageExternal listener, as the sendResponse will be removed from the specs (See https://developer.mozilla.org/docs/Mozilla/Add-ons/WebExtensions/API/runtime/onMessage)",c=o=>{const a={alarms:{clear:{minArgs:0,maxArgs:1},clearAll:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getAll:{minArgs:0,maxArgs:0}},bookmarks:{create:{minArgs:1,maxArgs:1},get:{minArgs:1,maxArgs:1},getChildren:{minArgs:1,maxArgs:1},getRecent:{minArgs:1,maxArgs:1},getSubTree:{minArgs:1,maxArgs:1},getTree:{minArgs:0,maxArgs:0},move:{minArgs:2,maxArgs:2},remove:{minArgs:1,maxArgs:1},removeTree:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1},update:{minArgs:2,maxArgs:2}},browserAction:{disable:{minArgs:0,maxArgs:1,fallbackToNoCallback:!0},enable:{minArgs:0,maxArgs:1,fallbackToNoCallback:!0},getBadgeBackgroundColor:{minArgs:1,maxArgs:1},getBadgeText:{minArgs:1,maxArgs:1},getPopup:{minArgs:1,maxArgs:1},getTitle:{minArgs:1,maxArgs:1},openPopup:{minArgs:0,maxArgs:0},setBadgeBackgroundColor:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setBadgeText:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setIcon:{minArgs:1,maxArgs:1},setPopup:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setTitle:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},browsingData:{remove:{minArgs:2,maxArgs:2},removeCache:{minArgs:1,maxArgs:1},removeCookies:{minArgs:1,maxArgs:1},removeDownloads:{minArgs:1,maxArgs:1},removeFormData:{minArgs:1,maxArgs:1},removeHistory:{minArgs:1,maxArgs:1},removeLocalStorage:{minArgs:1,maxArgs:1},removePasswords:{minArgs:1,maxArgs:1},removePluginData:{minArgs:1,maxArgs:1},settings:{minArgs:0,maxArgs:0}},commands:{getAll:{minArgs:0,maxArgs:0}},contextMenus:{remove:{minArgs:1,maxArgs:1},removeAll:{minArgs:0,maxArgs:0},update:{minArgs:2,maxArgs:2}},cookies:{get:{minArgs:1,maxArgs:1},getAll:{minArgs:1,maxArgs:1},getAllCookieStores:{minArgs:0,maxArgs:0},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}},devtools:{inspectedWindow:{eval:{minArgs:1,maxArgs:2,singleCallbackArg:!1}},panels:{create:{minArgs:3,maxArgs:3,singleCallbackArg:!0},elements:{createSidebarPane:{minArgs:1,maxArgs:1}}}},downloads:{cancel:{minArgs:1,maxArgs:1},download:{minArgs:1,maxArgs:1},erase:{minArgs:1,maxArgs:1},getFileIcon:{minArgs:1,maxArgs:2},open:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},pause:{minArgs:1,maxArgs:1},removeFile:{minArgs:1,maxArgs:1},resume:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1},show:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},extension:{isAllowedFileSchemeAccess:{minArgs:0,maxArgs:0},isAllowedIncognitoAccess:{minArgs:0,maxArgs:0}},history:{addUrl:{minArgs:1,maxArgs:1},deleteAll:{minArgs:0,maxArgs:0},deleteRange:{minArgs:1,maxArgs:1},deleteUrl:{minArgs:1,maxArgs:1},getVisits:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1}},i18n:{detectLanguage:{minArgs:1,maxArgs:1},getAcceptLanguages:{minArgs:0,maxArgs:0}},identity:{launchWebAuthFlow:{minArgs:1,maxArgs:1}},idle:{queryState:{minArgs:1,maxArgs:1}},management:{get:{minArgs:1,maxArgs:1},getAll:{minArgs:0,maxArgs:0},getSelf:{minArgs:0,maxArgs:0},setEnabled:{minArgs:2,maxArgs:2},uninstallSelf:{minArgs:0,maxArgs:1}},notifications:{clear:{minArgs:1,maxArgs:1},create:{minArgs:1,maxArgs:2},getAll:{minArgs:0,maxArgs:0},getPermissionLevel:{minArgs:0,maxArgs:0},update:{minArgs:2,maxArgs:2}},pageAction:{getPopup:{minArgs:1,maxArgs:1},getTitle:{minArgs:1,maxArgs:1},hide:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setIcon:{minArgs:1,maxArgs:1},setPopup:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setTitle:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},show:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},permissions:{contains:{minArgs:1,maxArgs:1},getAll:{minArgs:0,maxArgs:0},remove:{minArgs:1,maxArgs:1},request:{minArgs:1,maxArgs:1}},runtime:{getBackgroundPage:{minArgs:0,maxArgs:0},getPlatformInfo:{minArgs:0,maxArgs:0},openOptionsPage:{minArgs:0,maxArgs:0},requestUpdateCheck:{minArgs:0,maxArgs:0},sendMessage:{minArgs:1,maxArgs:3},sendNativeMessage:{minArgs:2,maxArgs:2},setUninstallURL:{minArgs:1,maxArgs:1}},sessions:{getDevices:{minArgs:0,maxArgs:1},getRecentlyClosed:{minArgs:0,maxArgs:1},restore:{minArgs:0,maxArgs:1}},storage:{local:{clear:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}},managed:{get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1}},sync:{clear:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}}},tabs:{captureVisibleTab:{minArgs:0,maxArgs:2},create:{minArgs:1,maxArgs:1},detectLanguage:{minArgs:0,maxArgs:1},discard:{minArgs:0,maxArgs:1},duplicate:{minArgs:1,maxArgs:1},executeScript:{minArgs:1,maxArgs:2},get:{minArgs:1,maxArgs:1},getCurrent:{minArgs:0,maxArgs:0},getZoom:{minArgs:0,maxArgs:1},getZoomSettings:{minArgs:0,maxArgs:1},goBack:{minArgs:0,maxArgs:1},goForward:{minArgs:0,maxArgs:1},highlight:{minArgs:1,maxArgs:1},insertCSS:{minArgs:1,maxArgs:2},move:{minArgs:2,maxArgs:2},query:{minArgs:1,maxArgs:1},reload:{minArgs:0,maxArgs:2},remove:{minArgs:1,maxArgs:1},removeCSS:{minArgs:1,maxArgs:2},sendMessage:{minArgs:2,maxArgs:3},setZoom:{minArgs:1,maxArgs:2},setZoomSettings:{minArgs:1,maxArgs:2},update:{minArgs:1,maxArgs:2}},topSites:{get:{minArgs:0,maxArgs:0}},webNavigation:{getAllFrames:{minArgs:1,maxArgs:1},getFrame:{minArgs:1,maxArgs:1}},webRequest:{handlerBehaviorChanged:{minArgs:0,maxArgs:0}},windows:{create:{minArgs:0,maxArgs:1},get:{minArgs:1,maxArgs:2},getAll:{minArgs:0,maxArgs:1},getCurrent:{minArgs:0,maxArgs:1},getLastFocused:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},update:{minArgs:2,maxArgs:2}}};if(Object.keys(a).length===0)throw new Error("api-metadata.json has not been included in browser-polyfill");class d extends WeakMap{constructor(t,l=void 0){super(l),this.createItem=t}get(t){return this.has(t)||this.set(t,this.createItem(t)),super.get(t)}}const y=n=>n&&typeof n=="object"&&typeof n.then=="function",C=(n,t)=>(...l)=>{o.runtime.lastError?n.reject(new Error(o.runtime.lastError.message)):t.singleCallbackArg||l.length<=1&&t.singleCallbackArg!==!1?n.resolve(l[0]):n.resolve(l)},E=n=>n==1?"argument":"arguments",N=(n,t)=>function(m,...p){if(p.length<t.minArgs)throw new Error(`Expected at least ${t.minArgs} ${E(t.minArgs)} for ${n}(), got ${p.length}`);if(p.length>t.maxArgs)throw new Error(`Expected at most ${t.maxArgs} ${E(t.maxArgs)} for ${n}(), got ${p.length}`);return new Promise((b,h)=>{if(t.fallbackToNoCallback)try{m[n](...p,C({resolve:b,reject:h},t))}catch(g){console.warn(`${n} API method doesn't seem to support the callback parameter, falling back to call it without a callback: `,g),m[n](...p),t.fallbackToNoCallback=!1,t.noCallback=!0,b()}else t.noCallback?(m[n](...p),b()):m[n](...p,C({resolve:b,reject:h},t))})},K=(n,t,l)=>new Proxy(t,{apply(m,p,b){return l.call(p,n,...b)}});let L=Function.call.bind(Object.prototype.hasOwnProperty);const $=(n,t={},l={})=>{let m=Object.create(null),p={has(h,g){return g in n||g in m},get(h,g,w){if(g in m)return m[g];if(!(g in n))return;let f=n[g];if(typeof f=="function")if(typeof t[g]=="function")f=K(n,n[g],t[g]);else if(L(l,g)){let I=N(g,l[g]);f=K(n,n[g],I)}else f=f.bind(n);else if(typeof f=="object"&&f!==null&&(L(t,g)||L(l,g)))f=$(f,t[g],l[g]);else if(L(l,"*"))f=$(f,t[g],l["*"]);else return Object.defineProperty(m,g,{configurable:!0,enumerable:!0,get(){return n[g]},set(I){n[g]=I}}),f;return m[g]=f,f},set(h,g,w,f){return g in m?m[g]=w:n[g]=w,!0},defineProperty(h,g,w){return Reflect.defineProperty(m,g,w)},deleteProperty(h,g){return Reflect.deleteProperty(m,g)}},b=Object.create(n);return new Proxy(b,p)},D=n=>({addListener(t,l,...m){t.addListener(n.get(l),...m)},hasListener(t,l){return t.hasListener(n.get(l))},removeListener(t,l){t.removeListener(n.get(l))}}),me=new d(n=>typeof n!="function"?n:function(l){const m=$(l,{},{getContent:{minArgs:0,maxArgs:0}});n(m)});let Q=!1;const Y=new d(n=>typeof n!="function"?n:function(l,m,p){let b=!1,h,g=new Promise(M=>{h=function(v){Q||(console.warn(u,new Error().stack),Q=!0),b=!0,M(v)}}),w;try{w=n(l,m,h)}catch(M){w=Promise.reject(M)}const f=w!==!0&&y(w);if(w!==!0&&!f&&!b)return!1;const I=M=>{M.then(v=>{p(v)},v=>{let F;v&&(v instanceof Error||typeof v.message=="string")?F=v.message:F="An unexpected error occurred",p({__mozWebExtensionPolyfillReject__:!0,message:F})}).catch(v=>{console.error("Failed to send onMessage rejected reply",v)})};return I(f?w:g),!0}),ce=({reject:n,resolve:t},l)=>{o.runtime.lastError?o.runtime.lastError.message===i?t():n(new Error(o.runtime.lastError.message)):l&&l.__mozWebExtensionPolyfillReject__?n(new Error(l.message)):t(l)},X=(n,t,l,...m)=>{if(m.length<t.minArgs)throw new Error(`Expected at least ${t.minArgs} ${E(t.minArgs)} for ${n}(), got ${m.length}`);if(m.length>t.maxArgs)throw new Error(`Expected at most ${t.maxArgs} ${E(t.maxArgs)} for ${n}(), got ${m.length}`);return new Promise((p,b)=>{const h=ce.bind(null,{resolve:p,reject:b});m.push(h),l.sendMessage(...m)})},Ae={devtools:{network:{onRequestFinished:D(me)}},runtime:{onMessage:D(Y),onMessageExternal:D(Y),sendMessage:X.bind(null,"sendMessage",{minArgs:1,maxArgs:3})},tabs:{sendMessage:X.bind(null,"sendMessage",{minArgs:2,maxArgs:3})}},O={clear:{minArgs:1,maxArgs:1},get:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}};return a.privacy={network:{"*":O},services:{"*":O},websites:{"*":O}},$(o,Ae,a)};s.exports=c(chrome)}else s.exports=globalThis.browser})})(ne);var ue=ne.exports;const k=re(ue),fe=[{property:"name",enumerable:!1},{property:"message",enumerable:!1},{property:"stack",enumerable:!1},{property:"code",enumerable:!0}],W=Symbol(".toJSON was called"),pe=e=>{e[W]=!0;const r=e.toJSON();return delete e[W],r},te=({from:e,seen:r,to_:s,forceEnumerable:i,maxDepth:u,depth:c})=>{const o=s||(Array.isArray(e)?[]:{});if(r.push(e),c>=u)return o;if(typeof e.toJSON=="function"&&e[W]!==!0)return pe(e);for(const[a,d]of Object.entries(e)){if(typeof Buffer=="function"&&Buffer.isBuffer(d)){o[a]="[object Buffer]";continue}if(d!==null&&typeof d=="object"&&typeof d.pipe=="function"){o[a]="[object Stream]";continue}if(typeof d!="function"){if(!d||typeof d!="object"){o[a]=d;continue}if(!r.includes(e[a])){c++,o[a]=te({from:e[a],seen:[...r],forceEnumerable:i,maxDepth:u,depth:c});continue}o[a]="[Circular]"}}for(const{property:a,enumerable:d}of fe)typeof e[a]=="string"&&Object.defineProperty(o,a,{value:e[a],enumerable:i?!0:d,configurable:!0,writable:!0});return o};function xe(e,r={}){const{maxDepth:s=Number.POSITIVE_INFINITY}=r;return typeof e=="object"&&e!==null?te({from:e,seen:[],forceEnumerable:!0,maxDepth:s,depth:0}):typeof e=="function"?`[Function: ${e.name||"anonymous"}]`:e}var V={exports:{}};const be=e=>typeof crypto<"u"&&typeof crypto.getRandomValues=="function"?()=>{const r=crypto.getRandomValues(new Uint8Array(1))[0];return(r>=e?r%e:r).toString(e)}:()=>Math.floor(Math.random()*e).toString(e),oe=(e=7,r=!1)=>Array.from({length:e},be(r?16:36)).join("");V.exports=oe;V.exports.default=oe;var he=V.exports;const ie=re(he);var we=/^((?:background$)|devtools|popup|options|content-script|window)(?:@(\d+)(?:\.(\d+))?)?$/,ae=e=>{const[,r,s,i]=e.match(we)||[];return{context:r,tabId:+s,frameId:i?+i:void 0}},B=e=>k[e],ye=()=>{var e,r,s;const i=k.runtime.getManifest();if(typeof window>"u")return"background";const u=((e=i.browser_action)==null?void 0:e.default_popup)||((r=i.action)==null?void 0:r.default_popup);return u&&new URL(k.runtime.getURL(u)).pathname===window.location.pathname?"popup":(s=i.options_ui)!=null&&s.page&&new URL(k.runtime.getURL(i.options_ui.page)).pathname===window.location.pathname?"options":"background"},A=B("devtools")?"devtools":B("tabs")?ye():B("extension")?"content-script":typeof document<"u"?"window":null,ee=ie(),U=new Map,ge=new Map,q=new Set,z=new Map,x=null,j,le;S();function S(){if(A===null)throw new Error("Unable to detect runtime context i.e webext-bridge can't figure out what to do");if((A==="window"||A==="content-script")&&window.addEventListener("message",ke),A==="content-script"&&top===window&&(x=k.runtime.connect(),x.onMessage.addListener(e=>{_(e)}),x.onDisconnect.addListener(()=>{x=null,S()})),A==="content-script"&&top!==window&&(x=k.runtime.connect(),x.onMessage.addListener(e=>{_(e)}),x.onDisconnect.addListener(()=>{x=null,S()})),A==="devtools"){const{tabId:e}=k.devtools.inspectedWindow,r=`devtools@${e}`;x=k.runtime.connect(void 0,{name:r}),x.onMessage.addListener(s=>{_(s)}),x.onDisconnect.addListener(()=>{x=null,S()})}if(A==="popup"||A==="options"){const e=`${A}`;x=k.runtime.connect(void 0,{name:e}),x.onMessage.addListener(r=>{_(r)}),x.onDisconnect.addListener(()=>{x=null,S()})}A==="background"&&k.runtime.onConnect.addListener(e=>{let r=e.name||`content-script@${e.sender.tab.id}`;const s=e.sender.frameId;s&&(r=`${r}.${s}`);const{context:i,tabId:u,frameId:c}=ae(r);!u&&i!=="popup"&&i!=="options"||(z.set(r,e),q.forEach(o=>{o.resolvedDestination===r&&(e.postMessage(o.message),q.delete(o))}),e.onDisconnect.addListener(()=>{z.delete(r)}),e.onMessage.addListener(o=>{var a;(a=o==null?void 0:o.origin)!=null&&a.context&&(o.origin.tabId=u,o.origin.frameId=c,_(o))}))})}function _(e){const{origin:r,destination:s}=e;if(!e.hops.includes(ee)&&(e.hops.push(ee),!(A==="content-script"&&[s,r].some(i=>(i==null?void 0:i.context)==="window")&&!le))){if(!s)return ve(e);if(s.context){if(A==="window")return G(window,e);if(A==="content-script"&&s.context==="window")return e.destination=null,G(window,e);if(["devtools","content-script","popup","options"].includes(A))return s.context==="background"&&(e.destination=null),x.postMessage(e);if(A==="background"){const{context:i,tabId:u,frameId:c}=s,{tabId:o}=r;i!=="window"?e.destination=null:e.destination.tabId=null;let a=["popup","options"].includes(i)?i:`${i==="window"?"content-script":i}@${u||o}`;c&&(a=`${a}.${c}`);const d=z.get(a);d?d.postMessage(e):q.add({resolvedDestination:a,message:e})}}}}async function ve(e){const{transactionId:r,messageID:s,messageType:i}=e,u=()=>{const o=U.get(r);if(o){const{err:a,data:d}=e;if(a){const y=a,C=self[y.name],E=new(typeof C=="function"?C:Error)(y.message);for(const N in y)E[N]=y[N];o.reject(E)}else o.resolve(d);U.delete(r)}},c=async()=>{let o,a,d=!1;try{const y=ge.get(s);if(typeof y=="function")o=await y({sender:e.origin,id:s,data:e.data,timestamp:e.timestamp});else throw d=!0,new Error(`[webext-bridge] No handler registered in '${A}' to accept messages with id '${s}'`)}catch(y){a=y}finally{if(a&&(e.err=xe(a)),_({...e,messageType:"reply",data:o,origin:{context:A,tabId:null},destination:e.origin,hops:[]}),a&&!d)throw o}};switch(i){case"reply":return u();case"message":return c()}}async function ke({data:e,ports:r}){if(!(A==="content-script"&&!le)){if(e.cmd==="__crx_bridge_verify_listening"&&e.scope===j&&e.context!==A)r[0].postMessage(!0);else if(e.cmd==="__crx_bridge_route_message"&&e.scope===j&&e.context!==A){const{payload:s}=e;A==="content-script"&&(s.origin={context:"window",tabId:null}),_(s)}}}function G(e,r){_e();const s=new MessageChannel,i=setTimeout(()=>{s.port1.onmessage=null,G(e,r)},300);s.port1.onmessage=()=>{clearTimeout(i),e.postMessage({cmd:"__crx_bridge_route_message",scope:j,context:A,payload:r},"*")},e.postMessage({cmd:"__crx_bridge_verify_listening",scope:j,context:A},"*",[s.port2])}function _e(){throw new Error(`webext-bridge uses window.postMessage to talk with other "window"(s), for message routing and stuff,which is global/conflicting operation in case there are other scripts using webext-bridge. Call Bridge#setNamespace(nsps) to isolate your app. Example: setNamespace('com.facebook.react-devtools'). Make sure to use same namespace across all your scripts whereever window.postMessage is likely to be used\``)}function H(e,r){ge.set(e,r)}async function J(e,r,s="background"){const i=typeof s=="string"?ae(s):s,u="Bridge#sendMessage ->";if(!i.context)throw new TypeError(`${u} Destination must be any one of known destinations`);if(A==="background"){const{context:c,tabId:o}=i;if(c!=="background"&&!o)throw new TypeError(`${u} When sending messages from background page, use @tabId syntax to target specific tab`)}return new Promise((c,o)=>{const a={messageID:e,data:r,destination:i,messageType:"message",transactionId:ie(),origin:{context:A,tabId:null},hops:[],timestamp:Date.now()};U.set(a.transactionId,{resolve:c,reject:o}),_(a)})}var T=class{constructor(e){this.handleStreamClose=()=>{this.isClosed||(this.isClosed=!0,this.emitter.emit("closed",!0),this.emitter.events={})},this.internalInfo=e,this.emitter=se(),this.isClosed=!1,T.initDone||(H("__crx_bridge_stream_transfer__",r=>{const{streamId:s,streamTransfer:i,action:u}=r.data,c=T.openStreams.get(s);c&&!c.isClosed&&(u==="transfer"&&c.emitter.emit("message",i),u==="close"&&(T.openStreams.delete(s),c.handleStreamClose()))}),T.initDone=!0),T.openStreams.set(e.streamId,this)}get info(){return this.internalInfo}send(e){if(this.isClosed)throw new Error("Attempting to send a message over closed stream. Use stream.onClose(<callback>) to keep an eye on stream status");J("__crx_bridge_stream_transfer__",{streamId:this.internalInfo.streamId,streamTransfer:e,action:"transfer"},this.internalInfo.endpoint)}close(e){e&&this.send(e),this.handleStreamClose(),J("__crx_bridge_stream_transfer__",{streamId:this.internalInfo.streamId,streamTransfer:null,action:"close"},this.internalInfo.endpoint)}onMessage(e){return this.getDisposable("message",e)}onClose(e){return this.getDisposable("closed",e)}getDisposable(e,r){const s=this.emitter.on(e,r);return Object.assign(s,{dispose:s,close:s})}},Z=T;Z.initDone=!1;Z.openStreams=new Map;var Ee=new Map,Ie=se();H("__crx_bridge_stream_open__",e=>new Promise(r=>{const{sender:s,data:i}=e,{channel:u}=i;let c=!1,o=()=>{};const a=()=>{const d=Ee.get(u);typeof d=="function"?(d(new Z({...i,endpoint:s})),c&&o(),r(!0)):c||(c=!0,o=Ie.on("did-change-stream-callbacks",a))};a()}));navigator.serviceWorker.register("../../background.js").then(e=>console.log("service worker: registered")).catch(e=>console.error(e));R.runtime.onMessage.addListener(async(e,r)=>{console.log("BG page received message",e,"from",r)});let P=0;R.tabs.onActivated.addListener(async({tabId:e})=>{if(!P){P=e;return}let r;try{r=await R.tabs.get(P),P=e}catch{return}J("tab-prev",{title:r.title},{context:"content-script",tabId:e})});H("get-current-tab",async()=>{try{const e=await R.tabs.get(P);return{title:e==null?void 0:e.title}}catch{return{title:void 0}}});
